extern crate cargo;
#[macro_use]
extern crate clap;
#[macro_use]
extern crate failure;
extern crate rust2rpm;

use cargo::{
    core::{Dependency, Source, SourceId},
    sources::RegistrySource,
    Config,
};
use clap::ArgMatches;
use failure::Error;
use rust2rpm::crates::dependencies_by_feature;

use std::{collections::BTreeMap, fmt};
/*
use std::hash::{Hash, Hasher};

enum DependencyType {
    Provides,
    Requires,
}

fn hash<H: Hash>(hashable: &H) -> u64 {
    #![allow(deprecated)]
    let mut hasher = ::std::hash::SipHasher::new();
    hashable.hash(&mut hasher);
    hasher.finish()
}
*/

fn do_package(matches: &ArgMatches) -> Result<(), Error> {
    let crate_name = matches.value_of("crate").unwrap();
    let crate_version = matches.value_of("version");

    let config = Config::default()?;
    let source_id = SourceId::crates_io(&config)?;

    let dependency = Dependency::parse_no_deprecated(crate_name, crate_version, &source_id)?;
    let mut registry = RegistrySource::remote(&source_id, &config);
    let summaries = registry.query_vec(&dependency)?;
    //summaries.sort_by(|a, b| b.package_id().partial_cmp(a.package_id()).unwrap());

    let summary = summaries
        .iter()
        .max_by_key(|s| s.package_id())
        .ok_or_else(|| {
            format_err!(
                concat!(
                    "Couldn't find any crate matching {} {}.\n",
                    "Try `cargo update` to update the crates.io index."
                ),
                dependency.package_name(),
                dependency.version_req()
            )
        })?;
    let package = registry.download(summary.package_id())?;
    let package = package.manifest();

    use rust2rpm::crates::{create_self_dependency, resolve_dependencies_for_feature};
    use rust2rpm::rpm::rpm_dep;

    let deps_by_feature = dependencies_by_feature(&package);

    println!("# Generated by {} v{}", crate_name!(), crate_version!());
    println!("");
    println!("%global crate {}", package.name());
    println!("");
    println!("Name:           rust-%{{crate}}");
    println!("Version:        {}", package.version());
    println!("Release:        1%{{?dist}}");
    //println!("Summary:        {}", package.description());
    println!("");
    //println!("License:        {}", package.license());
    //println!("URL:            {}", package.repository());
    println!("ExclusiveArch:  %{{rust_arches}}");
    println!();
    println!("BuildRequires:  rust-packaging");
    /* https://github.com/rust-lang/cargo/issues/5133
    let (default_features, default_deps) =
        resolve_dependencies_for_feature(&deps_by_feature, "default");
    for dep in default_deps {
        println!("BuildRequries:  {}", rpm_dep(&dep)?);
    }
    */
    for (_, (_, deps)) in &deps_by_feature {
        for dep in deps {
            println!("BuildRequires:  {}", rpm_dep(&dep)?);
        }
    }
    println!();
    println!("%description");
    println!("%{{summary}}.");
    println!();

    //println!("{}", rpm_pkg);
    //for pkg in rpm_subpkgs {
    //    println!("{}", pkg);
    //}

    for (feature, (features, deps)) in deps_by_feature {
        let pkg_name = match feature {
            "" => format!("%{{name}}-devel"),
            _ => format!("%{{name}}+{}-devel", feature),
        };
        println!("%package     -n {}", pkg_name);
        println!("Summary:        %{{summary}}");
        println!("BuildArch:      noarch");
        let selfdep = create_self_dependency(&package, &[feature]);
        println!("Provides:       {}", rpm_dep(&selfdep)?);
        if feature != "" {
            println!(
                "Requires:       {}",
                rpm_dep(&create_self_dependency(&package, &features))?
            );
        }
        for dep in deps {
            println!("Requires:       {}", rpm_dep(&dep)?);
        }
        println!();
        println!("%description -n {}", pkg_name);
        println!("%{{summary}}.");
        println!();
        println!("This package contains library source intended for building other packages");
        match feature {
            "" => println!("which use \"%{{crate}}\" crate."),
            _ => println!("which use \"{}\" feature of \"%{{crate}}\" crate.", feature),
        };
        println!();
        println!("%files       -n {}", pkg_name);
        match feature {
            "" => println!("%{{cargo_registry}}/%{{crate}}-%{{version}}/"),
            _ => println!("%ghost %{{cargo_registry}}/%{{crate}}-%{{version}}/Cargo.toml"),
        };
        println!();
    }
    /*
    for (feature, (f_deps, o_deps)) in dependencies_by_feature(&package) {
        if feature == "" {
            println!("rust-{}-devel", package.name());
        } else {
            println!("rust-{}+{}-devel", package.name(), feature);
        }
        for dep in f_deps {
            if dep == "" {
                println!("  → crate({})", package.name());
            } else {
                println!("  → crate({}:{})", package.name(), dep);
            }
        }
        for dep in o_deps {
            println!("  → crate({}) {}", dep.package_name(), dep.version_req());
        }
    }
    */

    Ok(())
}

fn main() -> Result<(), Error> {
    let m = clap_app!(rust2rpm =>
        (@setting SubcommandRequiredElseHelp)
        (version: crate_version!())
        (about: crate_description!())
        (@subcommand package =>
            (about: "Package a crate")
            (@arg crate: +required "Name of a crate")
            (@arg version: "Version of a crate to package")
        )
    ).get_matches();

    match m.subcommand() {
        ("package", Some(sm)) => do_package(sm)?,
        _ => unreachable!(),
    }

    Ok(())
}
